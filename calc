#!/usr/bin/env node
// TODO - to get rid of shift-reduce conflicts for "e bin_op e" expressions, I cannot have non-terminal bin_op rules, therefore they should be propagated up to generate multiple "e '+' e" rules.

// TODO - draw brackets if the precedence is not clear


const DEBUG = !!process.env["DEBUG"];

const parser = require("./parser.js");

// TODO - rename to leftPad
const buffer = (str, max) => {
  let bufferLength = max - str.toString().length;
  if(bufferLength < 0) bufferLength = 0;
  return " ".repeat(bufferLength);
}



let latexFormula = function (str) {
  let node = parser.parse(str);
  string = node.toString({style: "latex_se", brackets: true});
  // string = string.replace(/^\((.*)\)$/, (a, b) => b);
  return string;
}

let latexRule = function (name, fs) {
  let latexFs = fs.reverse()
  .map(f => f === "" ? "" : latexFormula(f))
  .map(f => `{${f}}`)
  .join('');
  return `\\prftree[r]{$${name}$}${latexFs}`;
}

let formulaStr = "(?X, ?X), ?Y |- AT? B : F?A xx F?B";
let node = parser.parse(formulaStr)

const formatTree = function (node, attrs) {
  let title = attrs.map(attr => attr.type.toUpperCase() + buffer(attr.type, attr.width)).join("")
  console.log(`${title}\n\nRoot\n`+node.toTree("", true, attrs))
}

formatTree(node, [
    {
      type: "location",
      width: 30
    },
    {
      type: "ownprecedence",
      width: 20
    }
  ])

console.log(latexFormula(formulaStr))


const rewriteLatexRule = function (str) {
  // Rewrite rules are bullshit
  const latexRewriteRules = [
    [ /\?\ X(\d*)/g, "\\Gamma$1" ],
    [ /\?\ Y(\d*)/g, "\\Delta$1" ],
    [ /\?\ Z(\d*)/g, "\\Theta$1" ],
    [ /\?\_F\ /g, "" ],
    [ /\?\_F\ /g, "" ],
    [ /\?\_F\ /g, "" ]
  ]
  // rewrite the result
  latexRewriteRules.forEach(rule => {
    str = str.replace(rule[0], (_, n) => rule[1].replace("$1", n === "" ? "" : "_" + n));
  })
  return str;
}

// let calculus = [];
// Object.keys(calc.rules).forEach(ctx => {
//   calculus.push(`\n\n\\subsubsection*{${ctx}}\n\n`)
//   calculus.push(`\\begin{tabularx}{\\linewidth}{CCC}\n`)
//   Object.keys(calc.rules[ctx]).forEach((ruleName, i) => {
//     let latexRuleName = calc.calc_structure_rules[ctx][ruleName].latex;
//     let ruleDef = calc.rules[ctx][ruleName];
//     let result = latexRule(latexRuleName, ruleDef);
//     let formattedResult = rewriteLatexRule(result);
//     calculus.push("  "+formattedResult);
//     if(i < Object.keys(calc.rules[ctx]).length - 1) {
//       if(i>0 && (i+1)%3 === 0) {
//         calculus.push("\n\\\\\\\\\n");
//       } else {
//         calculus.push("\n&\n");
//       }
//     }
//   })
//   calculus.push(`\n\\end{tabularx}\n`)
// })
//
// console.log(calculus.join(""));

