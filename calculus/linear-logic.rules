% Linear Logic Inference Rules (Extended Celf)
%
% This file defines the inference rules for Intuitionistic Linear Logic.

% =============================================================================
% Derivability Type
% =============================================================================

deriv: sequent -> type.

% =============================================================================
% Identity and Cut
% =============================================================================

% Identity: A ⊢ A
id: deriv (seq (struct A) A)
  @pretty "Id"
  @invertible true.

% Cut rule (admissible)
cut: deriv (seq G A)
  <- deriv (seq G' (struct A) B)
  <- deriv (seq G A)
  @pretty "Cut"
  @invertible false.

% =============================================================================
% Tensor Rules
% =============================================================================

% Tensor Right: Γ ⊢ A   Δ ⊢ B
%               ─────────────
%               Γ, Δ ⊢ A ⊗ B
tensor_r: deriv (seq (comma G D) (tensor A B))
  <- deriv (seq G A)
  <- deriv (seq D B)
  @pretty "⊗R"
  @invertible false.

% Tensor Left: Γ, A, B ⊢ C
%              ───────────
%              Γ, A ⊗ B ⊢ C
tensor_l: deriv (seq (comma G (struct (tensor A B))) C)
  <- deriv (seq (comma (comma G (struct A)) (struct B)) C)
  @pretty "⊗L"
  @invertible true.

% =============================================================================
% Linear Implication Rules
% =============================================================================

% Lollipop Right: Γ, A ⊢ B
%                 ─────────
%                 Γ ⊢ A ⊸ B
loli_r: deriv (seq G (loli A B))
  <- deriv (seq (comma G (struct A)) B)
  @pretty "⊸R"
  @invertible true.

% Lollipop Left: Γ ⊢ A   Δ, B ⊢ C
%                ─────────────────
%                Γ, Δ, A ⊸ B ⊢ C
loli_l: deriv (seq (comma (comma G (struct (loli A B))) D) C)
  <- deriv (seq G A)
  <- deriv (seq (comma D (struct B)) C)
  @pretty "⊸L"
  @invertible false.

% =============================================================================
% With (Additive Conjunction) Rules
% =============================================================================

% With Right: Γ ⊢ A   Γ ⊢ B
%             ─────────────
%             Γ ⊢ A & B
with_r: deriv (seq G (with A B))
  <- deriv (seq G A)
  <- deriv (seq G B)
  @pretty "&R"
  @invertible false.

% With Left (projection 1): Γ, A ⊢ C
%                           ─────────
%                           Γ, A & B ⊢ C
with_l1: deriv (seq (comma G (struct (with A B))) C)
  <- deriv (seq (comma G (struct A)) C)
  @pretty "&L₁"
  @invertible true.

% With Left (projection 2): Γ, B ⊢ C
%                           ─────────
%                           Γ, A & B ⊢ C
with_l2: deriv (seq (comma G (struct (with A B))) C)
  <- deriv (seq (comma G (struct B)) C)
  @pretty "&L₂"
  @invertible true.

% =============================================================================
% Bang (Exponential) Rules
% =============================================================================

% Promotion: !Γ ⊢ A
%            ──────
%            !Γ ⊢ !A
promotion: deriv (seq G (bang A))
  <- deriv (seq G A)
  @pretty "!R"
  @invertible false
  @requires_bang_context true.

% Dereliction: Γ, A ⊢ C
%              ────────
%              Γ, !A ⊢ C
dereliction: deriv (seq (comma G (struct (bang A))) C)
  <- deriv (seq (comma G (struct A)) C)
  @pretty "!L"
  @invertible true.

% Weakening: Γ ⊢ C
%            ──────
%            Γ, !A ⊢ C
weakening: deriv (seq (comma G (struct (bang A))) C)
  <- deriv (seq G C)
  @pretty "W"
  @invertible true.

% Contraction: Γ, !A, !A ⊢ C
%              ─────────────
%              Γ, !A ⊢ C
contraction: deriv (seq (comma G (struct (bang A))) C)
  <- deriv (seq (comma (comma G (struct (bang A))) (struct (bang A))) C)
  @pretty "C"
  @invertible true.

% =============================================================================
% Unit Rules
% =============================================================================

% Unit Right: ⊢ I
one_r: deriv (seq empty one)
  @pretty "IR"
  @invertible false.

% Unit Left: Γ ⊢ C
%            ──────
%            Γ, I ⊢ C
one_l: deriv (seq (comma G (struct one)) C)
  <- deriv (seq G C)
  @pretty "IL"
  @invertible true.
