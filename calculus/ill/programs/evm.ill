% EVM
%
% 00   STOP
% 01   ADD           *
% 02   MUL           *
% 03   SUB           *
% 0a   EXP           *

% 10   LT            *
% 11   GT            *
% 14   EQ
% 15   ISZERO        ?
% 16   AND           *
% 17   OR            *
% 19   NOT           *

% 20   SHA3          TODO

% 30   ADDRESS
% 31   BALANCE
% 33   CALLER
% 34   CALLVALUE     *
% 35   CALLDATALOAD  *
% 36   CALLDATASIZE  *
% 37   CALLDATACOPY  *

% 42   TIMESTAMP     *
% 45   GASLIMIT      *

% 54   SLOAD
% 55   SSTORE        *
% 56   JUMP          *
% 57   JUMPI
% 5a   GAS
% 5b   JUMPDEST

% 60   PUSH1
% 73   PUSH20        *

% 80   DUP1
% 81   DUP2          *
% 82   DUP3          *

% 90   SWAP1         *

% a4   LOG4          *

% f1   CALL          ?
% fe   INVALID       *
% fd   REVERT        *

invalid: type.
revert: type.
log0: type.
log1: bin -> type.
log2: bin -> bin -> type.
log3: bin -> bin -> bin -> type.
log4: bin -> bin -> bin -> bin -> type.
stop: type.
pc: bin -> type.
gas: bin -> type.
sh: nat -> type.
code: bin -> bin -> type.
stack: nat -> bin -> type.
storage: bin -> bin -> type.
sender: bin -> type.
address: bin -> type.
balance: bin -> bin -> type.
callvalue: bin -> type.
calldata: bin -> bin -> bin -> type.
calldatasize: bin -> type.
debug: bin -> type.
memory: bin -> bin -> bin -> type.
mh: bin -> type.
timestamp: bin -> type.
gaslimit: bin -> type.
concat: bin -> bin -> bin.
sha3: bin -> bin.
call: bin -> bin -> bin -> bin -> bin -> bin -> bin -> type.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  00

evm/stop:
  pc PC *
  code PC 0x00 *
  !inc PC PC'
  -o {
    code PC 0x00 *
    stop
  }.

evm/add:
  pc PC *
  code PC 0x01 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) A *
  stack SH  B *
  !plus A B C
  -o {
    code PC 0x01 *
    pc PC' *
    sh (s SH) *
    stack SH C
  }.

evm/mul:
  pc PC *
  code PC 0x02 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) A *
  stack SH  B *
  !trim A A' *
  !trim B B' *
  !mul A B C *
  !to256 C C'
  -o {
    code PC 0x02 *
    pc PC' *
    sh (s SH) *
    stack SH C'
  }.

evm/sub:
  pc PC *
  code PC 0x03 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) A *
  stack SH  B *
  !plus C B A
  -o {
    code PC 0x03 *
    pc PC' *
    sh (s SH) *
    stack SH C
  }.

evm/exp:
  pc PC *
  code PC 0x0a *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) Base *
  stack SH  Exponent *
  !trim Base Base' *
  !trim Exponent Exponent' *
  !exp Base' Exponent' Result *
  !to256 Result Result'
  -o {
    debug Base' *
    debug Exponent' *
    code PC 0x0a *
    pc PC' *
    sh (s SH) *
    stack SH Result'
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  10

%evm/eq_eqeq:
%  code PC 0x14 *
%  pc PC *
%  !inc PC PC' *
%  gas GAS *
%  !plus 2 GAS GAS' * %10 = 2 *
%  sh SH'' *
%  !inc SH' SH'' *
%  !inc SH SH' *
%  stack SH' X *
%  stack SH X
%  -o {
%    pc PC' *
%    gas GAS' *
%    code PC 0x14 *
%    sh SH' *
%    stack SH 1
%  }.

evm/eq:
  pc PC *
  code PC 0x14 *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH Y
  -o {
    pc PC' *
    gas GAS' *
    code PC 0x14 *
    sh (s SH) *
    ((!neq X Y -o {
      stack SH 0
    }) &
    (!eq X Y -o {
      stack SH 1
    }))
  }.

evm/iszero_eq:
  pc PC *
  code PC 0x15 *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS' *
  sh (s SH) *
  stack SH 0
  -o {
    code PC 0x15 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    stack SH 1
  }.

evm/iszero_neq:
  pc PC *
  code PC 0x15 *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS' *
  sh (s SH) *
  stack SH V *
  !neq V 0
  -o {
    code PC 0x15 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    stack SH 0
  }.

evm/lt:
  pc PC *
  code PC 0x10 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH Y *
  !gt Y X 0 Z *
  !to256 Z Z'
  -o {
    code PC 0x10 *
    pc PC' *
    sh (s SH) *
    stack SH Z'
  }.

evm/gt:
  pc PC *
  code PC 0x11 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH Y *
  !gt X Y 0 Z *
  !to256 Z Z'
  -o {
    code PC 0x11 *
    pc PC' *
    sh (s SH) *
    stack SH Z'
  }.

evm/and:
  pc PC *
  code PC 0x16 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH  Y *
  !and X Y Z
  -o {
    code PC 0x16 *
    pc PC' *
    sh (s SH) *
    stack SH Z
  }.

evm/or:
  pc PC *
  code PC 0x17 *
  !inc PC PC' *
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH  Y *
  !or X Y Z
  -o {
    code PC 0x17 *
    pc PC' *
    sh (s SH) *
    stack SH Z
  }.

evm/not:
  pc PC *
  code PC 0x19 *
  !inc PC PC' *
  sh (s SH) *
  stack SH X *
  !not X Y
  -o {
    code PC 0x19 *
    pc PC' *
    sh (s SH) *
    stack SH Y
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  20

% TODO - dirty -.-, I don't want to implemet sha3 in here
% TODO - summ over memory

concatMemory: bin -> bin -> bin -> type.
unblockConcatMemory: bin -> type.
concatMemory/z: concatMemory X X Z
  -o {
    unblockConcatMemory Z
  }.
concatMemory/s:
  concatMemory Pos To Z *
  !neq Pos To           *
  memory Pos Size V     *
  !plus Pos Size Pos'
  -o {
    memory Pos Size V *
    concatMemory Pos' To (concat Z V)
  }.

evm/sha3:
  pc PC             *
  code PC 0x20      *
  !inc PC PC'       *
  gas GAS           *
  !inc GAS GAS'     *
  sh (s (s SH))     *
  stack (s SH) From *
  stack SH  To
  -o {
    concatMemory From To 0 *
    (unblockConcatMemory Z -o {
      code PC 0x20 *
      pc PC' *
      gas GAS' *
      stack SH (sha3 Z) *
      sh (s SH)
    })
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  30

evm/address:
  pc PC *
  code PC 0x30 *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh SH *
  address A
  -o {
    pc PC' *
    gas GAS' *
    code PC 0x30 *
    sh (s SH) *
    address A *
    stack SH A
  }.

evm/balance:
  pc PC *
  code PC 0x31 *
  !inc PC PC' *
  gas GAS *
  !plus 512 GAS GAS' *
  sh (s SH) *
  stack SH A *
  balance A B
  -o {
    code PC 0x31 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    stack SH B *
    balance A B
  }.

evm/caller:
  pc PC *
  code PC 0x33 *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh SH *
  sender SENDER
  -o {
    pc PC' *
    gas GAS' *
    code PC 0x33 *
    sh (s SH) *
    sender SENDER *
    stack SH SENDER
  }.

evm/callvalue:
  code PC 0x34 *
  pc PC *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh SH *
  callvalue Value
  -o {
    pc PC' *
    gas GAS' *
    code PC 0x34 *
    sh (s SH) *
    callvalue Value *
    stack SH Value
  }.

%calldatasize: bin -> bin -> bin -> type.
%calldatasize/z:
%  calldatasize PC 0 Size *
%  sh SH *
%  !inc SH SH'
%  -o {
%    sh SH' *
%    stack SH Size *
%    pc PC
%  }.
%calldatasize/si:
%  calldatasize PC (i X) Size *
%  !inc Size Size'
%  -o {
%    calldatasize PC X Size'
%  }.
%calldatasize/so:
%  calldatasize PC (o X) Size *
%  !inc Size Size'
%  -o {
%    calldatasize PC X Size'
%  }.


% TODO - calldataload start
%calldataload: bin -> type.
%calldataload/z:
%  calldataload Start
%  -o S
%    unblock
%  }.
%pushat/s:
%  pushat PC PC_Target *
%  !neq PC PC_Target *
%  code PC V *
%  !inc PC PC' *
%  sh SH' *
%  !inc SH SH' *
%  stack SH Number *
%  !plus (o (o (o (o (o (o (o (o Number)))))))) V V'
%  -o {
%    pushat PC' PC_Target *
%    code PC V *
%    sh SH' *
%    stack SH V'
%  }.

% TODO
% current assumption: calldatasize < 32
evm/calldataload:
  pc         PC         *
  code       PC    0x35 *
  !inc       PC    PC'  *
  sh         (s SH)     *
  stack      SH    POS  *
  calldata   POS   Size V
  -o {
    code PC 0x35 *
    stack SH V *
    sh (s SH) *
    pc PC' *
    calldata   POS   Size V
  }.

evm/calldatasize:
  pc PC *
  code PC 0x36 *
  !inc PC PC' *
  calldatasize Size *
  sh SH
  -o {
    sh (s SH) *
    stack SH Size *
    code PC 0x36 *
    calldatasize Size *
    pc PC'
  }.

calldatacopy: bin -> bin -> bin -> type.
unblock: type.

calldatacopy/z:
  calldatacopy Ms Cs Cs
  -o {
    unblock
  }.

% TODO
calldatacopy/s:
  calldatacopy Ms Cs Ce *
  calldata Cs Size D *
  !neq Cs Ce *
  !plus Cs Size Cs' *
  !plus Ms Size Ms'
  -o {
    memory Ms Size D *
    calldata Cs Size D *
    calldatacopy Ms' Cs' Ce
  }.

evm/calldatacopy:
  pc PC *
  code PC 0x37 *
  !inc PC PC' *
  sh (s (s (s SH))) *
  stack (s (s SH))         Mem_start      *
  stack (s SH)             Calldata_start *
  stack SH                 Copy_length    *
  !plus Calldata_start Copy_length Calldata_end
%TODO fill memory with zeros in  case mem_start is bigger then the current mem_height
  -o {
    code PC 0x37 *
    sh SH *
    calldatacopy Mem_start Calldata_start Calldata_end *
    (unblock -o {pc PC'})
  }.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  40

evm/timestamp:
  pc PC *
  code PC 0x42 *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh SH *
  timestamp TS
  -o {
    code PC 0x42 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    timestamp TS *
    stack SH TS
  }.

evm/gaslimit:
  pc PC *
  code PC 0x45 *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2 *
  sh SH *
  gaslimit TS
  -o {
    code PC 0x45 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    gaslimit TS *
    stack SH TS
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  50


evm/sload:
  pc PC *
  code PC 0x54 *
  !inc PC PC' *
  gas GAS *
  !plus 512 GAS GAS' *
  sh (s SH) *
  stack SH KEY *
  storage KEY V
  -o {
    pc PC' *
    gas GAS' *
    code PC 0x54 *
    sh (s SH) *
    stack SH V *
    storage KEY V
  }.

evm/sstore:
  pc PC *
  code PC 0x55 *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS' *          %simplified
  sh (s (s SH)) *
  stack (s SH) Pos *
  stack SH  Val *
  storage Pos Z
  -o {
    code PC 0x55 *
    pc PC' *
    gas GAS' *
    sh SH *
    storage Pos Val
  }.


evm/jump:
  pc PC *
  code PC 0x56 *
  gas GAS *
  !plus 8 GAS GAS' *
  sh (s SH) *
  stack SH V
  -o {
    code PC 0x56 *
    pc V *
    sh SH *
    gas GAS'
  }.

evm/jumpi_neq:
  pc PC *
  code PC 0x57 *
  gas GAS *
  !plus 10 GAS GAS' * %1010 = 10 *
  sh (s (s SH)) *
  stack (s SH) NPC *
  stack SH C *
  !neq C 0
  -o {
    code PC 0x57 *
    sh SH *
    gas GAS' *
    pc NPC
  }.

evm/jumpi_eq:
  pc PC *
  code PC 0x57 *
  !inc PC PC' *
  gas GAS *
  !plus 16 GAS GAS' *
  sh (s (s SH)) *
  stack (s SH) NPC *
  stack SH 0
  -o {
    code PC 0x57 *
    sh SH *
    gas GAS' *
    pc PC'
  }.

evm/gas:
  pc PC *
  code PC 0x5a *
  !inc PC PC' *
  gas GAS *
  !plus 2 GAS GAS' * %10 = 2
  sh SH
  -o {
    code PC 0x5a *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    stack SH GAS'
  }.

evm/jumpdest:
  pc PC *
  code PC 0x5b *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS'
  -o {
    code PC 0x5b *
    pc PC' *
    gas GAS'
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  60

evm/push1:
  pc PC *
  code PC 0x60 *
  gas GAS *
  !plus 3 GAS GAS' *
  code PC' V *
  !inc PC PC' *
  !inc PC' PC'' *
  sh SH
  -o {
    pc PC'' *
    gas GAS' *
    code PC 0x60 *
    code PC' V *
    sh (s SH) *
    stack SH V
  }.

% pushat PC x PC_Target
%pushat: bin -> bin -> type.
%pushat/z:
%  pushat PC PC
%  -o {
%    pc PC
%  }.
%pushat/s:
%  pushat PC PC_Target *
%  !neq PC PC_Target *
%  code PC V *
%  !inc PC PC' *
%  sh SH' *
%  !inc SH SH' *
%  stack SH Number *
%  !plus (o (o (o (o (o (o (o (o Number)))))))) V V'
%  -o {
%    pushat PC' PC_Target *
%    code PC V *
%    sh SH' *
%    stack SH V'
%  }.

evm/push20:
  pc PC *
  code PC 0x73 *
  !inc PC PC' *
  code PC' V *
  !plus 20 PC' PC_Target *
  gas GAS *
  !plus 3 GAS GAS' *
  sh SH
  -o {
    code PC 0x73 *
    pc PC_Target *
    sh (s SH) *
    stack SH V *
    gas GAS'
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  70

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  80

evm/dup1:
  pc PC *
  code PC 0x80 *
  !inc PC PC' *
  gas GAS *
  !plus 3 GAS GAS' * %11 = 3
  sh (s SH) *
  stack SH V
  -o {
    code PC 0x80 *
    pc PC' *
    gas GAS' *
    sh (s (s SH)) *
    stack SH V *
    stack (s SH) V
  }.

evm/dup2:
  pc PC *
  code PC 0x81 *
  !inc PC PC' *
  gas GAS *
  !plus 3 GAS GAS' * %11 = 3
  sh (s (s SH)) *
  stack SH V
  -o {
    code PC 0x81 *
    pc PC' *
    gas GAS' *
    sh (s (s (s SH))) *
    stack SH V *
    stack (s (s SH)) V
  }.

evm/dup3:
  pc PC *
  code PC 0x82 *
  !inc PC PC' *
  gas GAS *
  !plus 3 GAS GAS' * %11 = 3
  sh (s (s (s SH))) *
  stack SH V
  -o {
    code PC 0x82 *
    pc PC' *
    gas GAS' *
    sh (s (s (s (s SH)))) *
    stack SH V *
    stack (s (s (s SH))) V
  }.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  90

evm/swap1:
  pc PC *
  code PC 0x90 *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS' *                  % simplified
  sh (s (s SH)) *
  stack (s SH) X *
  stack SH  Y
  -o {
    code PC 0x90 *
    pc PC' *
    gas GAS' *
    sh (s (s SH)) *
    stack (s SH) Y *
    stack SH  X
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  a0

% TODO - memory
evm/log4:
  pc PC *
  code PC 0xa4 *
  !inc PC PC' *
  gas GAS *
  !inc GAS GAS' *
  sh (s (s (s (s (s (s SH)))))) *
  stack (s (s (s (s (s SH))))) V0      *
  stack (s (s (s (s SH))))  V1      *
  stack (s (s (s SH)))   V2      *
  stack (s (s SH))    V3      *
  stack (s SH)     V4      *
  stack SH      V5
  -o {
    code PC 0xa4 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    log4 V2 V3 V4 V5
  }.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  b0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  c0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  d0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  e0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  f0

% SIMPLIFIED CALL - TODO
evm/call:
  pc PC *
  code PC 0xf1 *
  !inc PC PC' *
  gas GAS *                        % simplified
  !inc GAS GAS' *                  % simplified
  sh    (s (s (s (s (s (s (s SH )))))))           *
  stack    (s (s (s (s (s (s SH ))))))   GAS_T       *
  stack       (s (s (s (s (s SH )))))    TO_T        *
  stack          (s (s (s (s SH ))))     VALUE_T     *
  stack             (s (s (s SH )))      InOffset_T  *
  stack                (s (s SH ))       InSize_T    *
  stack                   (s SH)         OutOffset_T *
  stack                      SH          OutSize_T
  % !plus BALANCE VALUE VALUE' *
  % !plus New_Value VALUE Contract_BALANCE *
  % balance ADDRESS BALANCE *
  % address Contract_Address *
  % balance Contract_Address Contract_BALANCE
  -o {
    code PC 0xf1 *
    pc PC' *
    gas GAS' *
    sh (s SH) *
    stack SH 1 *
    call GAS_T TO_T VALUE_T InOffset_T InSize_T OutOffset_T OutSize_T
    % address Contract_Address *
    % balance ADDRESS VALUE' *
    % balance Contract_Address New_Value
  }.

evm/invalid:
  pc PC *
  code PC 0xfe
  -o {
    code PC 0xfe *
    invalid
  }.

evm/revert:
  pc PC *
  code PC 0xfd
  -o {
    code PC 0xfd *
    revert
  }.
