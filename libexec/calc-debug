#!/usr/bin/env node

const calc = require('../ll.json');
const clc = require('cli-color');
const helper = require('../lib/helper.js');

const calcParser = require("../lib/parser.js");
const Parser = calcParser(calc);
const calc_ = Parser.calc;


let args = process.argv.slice(2);

const drawPrecedence = function () {

  var db = [];
  Object.keys(calc_.calc_structure).forEach(ctxName => {
    Object.keys(calc_.calc_structure[ctxName]).forEach(ruleName => {
      let rule = calc_.calc_structure[ctxName][ruleName];
      let types = Array.isArray(rule.type) ? rule.type : (rule.type ? [rule.type] : [] );
      let precedence = "precedence" in rule && rule.precedence.slice(-1)[0] || 0;

      let tmp = rule.ascii || "";

      let i=0;
      while((tmp.match(/\s+(_)|(_)\s+|^(_)$/) || []).length > 0) {
        tmp = tmp.replace(/\s+(_)|(_)\s+|^(_)$/, " "+types[i++]+ " " );
      }
      let ascii = tmp.trim().replace(/\s+/g," ");


      db.push({
        ctxName,
        ruleName,
        precedence,
        ascii
      });
    })
  })

  db = db.sort((a, b) => b.precedence - a.precedence);

  let attrs = ["precedence", "ascii", "ctxName", "ruleName"];

  let formattedTable = helper.formatDb(db, attrs);

  console.log(formattedTable)

}

const drawGrammar = function () {
  let grammar = Parser.grammar;
  Object.keys(grammar.bnf).forEach(k => {
    let rules = grammar.bnf[k].map(r => r[0].trim())
    console.log(`${k} = \n    ${rules.join("\n  | ")}\n`);
  })
}

const drawDepGraph = function () {
  let calc = Parser.calc.calc_structure;
  let depGraph = {};
  let keys = Object.keys(calc)
    .forEach(ctxName => {
    let ctx = calc[ctxName];
    let deps = {};
      Object.keys(ctx)
      .forEach(ruleName => {
      let rule = ctx[ruleName];
      if("type" in rule) (Array.isArray(rule.type) ? rule.type : [])
          .forEach(t => deps[t] = true)
    })
    depGraph[ctxName] = Object.keys(deps);
  });
  let depGraphStr = JSON.stringify(depGraph, false, 2);
  let depOrder = [];
  let got = true;
  let rmKey = key => Object.keys(depGraph)
    .forEach(k => {
      let i = depGraph[k].indexOf(key);
      if(i > -1) {
        depGraph[k].splice(i, 1);
      }
    })
  // rm mutual
  Object.keys(depGraph)
  .forEach(key => {
    let i = depGraph[key].indexOf(key);
    if(i > -1) {
      depGraph[key].splice(i, 1)
    }
  })
  rmKey("string");
  while (got) {
    got = false;
    let rmEl = Object.keys(depGraph)
    .find(e => depGraph[e].length == 0)
    if(rmEl) {
      got = true;
      depOrder.push(rmEl);
      delete depGraph[rmEl];
      rmKey(rmEl);
    }
  }
  if(Object.keys(depGraph).length == 0) {
    console.log(`${clc.green("Termination order found:")}\n  ${depOrder.join("\n  ")}`);
  } else {
    console.log(clc.red("Graph contains non-trivial cycles!"), depGraphStr);
  }
}


if(args.length === 0) {
console.log(`
  CALC DEBUGGER

  Usage:
    calc debug precedence  - precedence list
    calc debug grammar     - EBNF grammar of the calculus structure
    calc debug depgraph    - nonterminal dependencies

`);
}


if(args.indexOf("precedence") > -1) {
  drawPrecedence();
}

if(args.indexOf("grammar") > -1) {
  drawGrammar();
}

if(args.indexOf("depgraph") > -1) {
  drawDepGraph();
}


// Object.keys(calc.calc_structure)
// .forEach(ctxName => {console.log("\n");Object.keys(calc.calc_structure[ctxName]).forEach(ruleName => {
//   let ctx = calc.calc_structure[ctxName];
//   let rule = ctx[ruleName];
//
//   console.log(`${ctxName.slice(0,5)} ${ruleName.slice(0,3)}..${ruleName.slice(-3)} - ${"ascii" in rule && rule.ascii.slice(0,2) || clc.red("x")}`);
// })})
