#!/usr/bin/env node
/**
 * Export calculus specification to HTML/PDF-ready format
 *
 * Usage: ./libexec/calc-export [--full]
 *
 * Outputs a standalone HTML file with:
 * - Syntax grammar (BNF-style)
 * - Metavariable conventions
 * - All inference rules grouped by category
 */

const fs = require('fs');
const path = require('path');

const calc = require('../ll.json');
const Calc = require('../lib/calc.js');
const Node = require('../lib/node.js');
const genParser = require('../lib/parser.js');

// Initialize calculus and parser
Calc.init(calc);
const { parser } = genParser(calc);
parser.yy.Node = Node;

const FULL_MODE = process.argv.includes('--full');
const META_MODE = process.argv.includes('--meta');

// Prettify metavariables in LaTeX string
// Maps ASCII parsing conventions → standard math notation
function prettifyMetavars(latex) {
  // Structure metavariables: ? X → Γ, ? Y → Δ, etc.
  // These appear in latex as "? X" (with space)
  latex = latex.replace(/\? X\b/g, '\\Gamma');
  latex = latex.replace(/\? Y\b/g, '\\Delta');
  latex = latex.replace(/\? Z\b/g, '\\Sigma');
  latex = latex.replace(/\? W\b/g, '\\Pi');
  latex = latex.replace(/\? V\b/g, '\\Theta');

  // Atomic prop metavariables in Id rule: "? A" when used as atom
  // Context: in Id rule it's "-- : ? A |- -- : ? A" for atoms
  // We want atoms to be p, q, r but formulas to be A, B, C
  // For now, treat standalone "? A" after colon as atom → p
  latex = latex.replace(/: \? A\b/g, ': p');
  latex = latex.replace(/: \? B\b/g, ': q');
  latex = latex.replace(/: \? C\b/g, ': r');

  // Remaining "? A" etc are formula vars (already handled by parser as A, B, C)
  // The parser already converts F?A → A in latex output

  // Anonymous terms: -- → ·
  latex = latex.replace(/-- :/g, '\\cdot\\,{:}');
  latex = latex.replace(/--/g, '\\cdot');

  // Clean up extra spaces
  latex = latex.replace(/\s+/g, ' ').trim();

  return latex;
}

// Helper: convert rule string to LaTeX
function ruleToLatex(ruleStr) {
  try {
    const node = parser.parse(ruleStr);
    let latex = node.toString({ style: 'latex' });
    return prettifyMetavars(latex);
  } catch (e) {
    return ruleStr; // fallback to raw string
  }
}

// Helper: escape for HTML (but preserve & in LaTeX contexts like \&)
function escapeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Escape for HTML attribute in non-LaTeX context
function escapeHtmlFull(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Generate syntax section
function generateSyntax() {
  const structure = calc.calc_structure;
  let html = '<section id="syntax">\n<h2>Syntax</h2>\n';

  // Key types to show
  const keyTypes = ['Formula', 'Structure', 'Sequent'];

  for (const typeName of keyTypes) {
    if (!structure[typeName]) continue;

    const rules = structure[typeName];
    const variants = Object.keys(rules).map(ruleName => {
      const rule = rules[ruleName];
      const latex = rule.latex || rule.ascii || ruleName;
      return latex.replace(/_/g, ' \\_ ');
    });

    html += `<div class="syntax-rule">`;
    html += `<span class="type-name">${typeName}</span> ::= `;
    html += variants.join(' | ');
    html += `</div>\n`;
  }

  html += '</section>\n';
  return html;
}

// Generate connectives table
function generateConnectives() {
  const structure = calc.calc_structure;
  let html = '<section id="connectives">\n<h2>Connectives</h2>\n';
  html += '<table class="connectives-table">\n';
  html += '<tr><th>Name</th><th>ASCII</th><th>LaTeX</th><th>Polarity</th></tr>\n';

  const polarity = calc.calc_structure_rules_meta?.polarity || {};

  // Formula connectives
  if (structure.Formula) {
    for (const [ruleName, rule] of Object.entries(structure.Formula)) {
      if (ruleName.startsWith('Formula_Freevar')) continue;
      if (ruleName === 'Formula_Atprop') continue;
      if (ruleName === 'Formula_Bin') continue; // internal

      const ascii = rule.ascii || '-';
      const latex = rule.latex || ascii;
      const pol = polarity[ruleName] || '-';

      html += `<tr>`;
      html += `<td><code>${ruleName.replace('Formula_', '')}</code></td>`;
      html += `<td><code>${escapeHtml(ascii)}</code></td>`;
      html += `<td class="latex-cell" data-latex="${escapeHtml(latex)}"></td>`;
      html += `<td>${pol}</td>`;
      html += `</tr>\n`;
    }
  }

  // Binary operators
  if (structure.Formula_Bin_Op) {
    for (const [ruleName, rule] of Object.entries(structure.Formula_Bin_Op)) {
      const ascii = rule.ascii || '-';
      const latex = rule.latex || ascii;
      const pol = polarity[ruleName] || '-';

      html += `<tr>`;
      html += `<td><code>${ruleName.replace('Formula_', '')}</code></td>`;
      html += `<td><code>${escapeHtml(ascii)}</code></td>`;
      html += `<td class="latex-cell" data-latex="${escapeHtml(latex)}"></td>`;
      html += `<td>${pol}</td>`;
      html += `</tr>\n`;
    }
  }

  html += '</table>\n</section>\n';
  return html;
}

// Generate metavariables section
function generateMetavariables() {
  let html = '<section id="metavariables">\n<h2>Metavariables</h2>\n';
  html += '<table class="meta-table">\n';
  html += '<tr><th>ASCII</th><th>Display</th><th>Meaning</th></tr>\n';

  const metas = [
    ['?X, ?Y, ?Z', '\\Gamma, \\Delta, \\Sigma', 'Structure metavariables'],
    ['F?A, F?B, F?C', 'A, B, C', 'Formula metavariables'],
    ['A?A, A?B', 'p, q', 'Atomic proposition metavariables'],
    ['--', '\\cdot', 'Anonymous term'],
    ['[A]', '[A]', 'Focused formula'],
  ];

  for (const [ascii, display, meaning] of metas) {
    html += `<tr>`;
    html += `<td><code>${escapeHtml(ascii)}</code></td>`;
    html += `<td class="latex-cell" data-latex="${escapeHtml(display)}"></td>`;
    html += `<td>${meaning}</td>`;
    html += `</tr>\n`;
  }

  html += '</table>\n</section>\n';
  return html;
}

// Generate a single inference rule HTML
function generateRule(name, ruleArray, latexName) {
  const conclusion = ruleArray[0];
  const premises = ruleArray.slice(1);

  const conclusionLatex = ruleToLatex(conclusion);
  const premisesLatex = premises.map(p => ruleToLatex(p));

  // Convert rule name to proper LaTeX
  // Rule names like \otimes_L should render the symbol + subscript
  let ruleNameLatex = (latexName || name)
    .replace(/_([LR])/g, '_{$1}')      // _L -> _{L}
    .replace(/_(\d+)/g, '_{$1}');      // _1 -> _{1}

  // If it contains LaTeX commands or special symbols, use math mode
  // Otherwise use text mode
  // Match: \word, \&, \{, \}, or bare ! (bang operator)
  const hasMathCmd = /\\([a-zA-Z]+|[&{}])/.test(ruleNameLatex) || /^!/.test(ruleNameLatex);
  if (!hasMathCmd) {
    ruleNameLatex = `\\textsf{${ruleNameLatex}}`;
  }

  let html = '<div class="inference-rule">\n';

  // Premises
  html += '<div class="rule-premises">\n';
  if (premisesLatex.length === 0) {
    html += '<span class="rule-formula no-premise"></span>\n';
  }
  for (const p of premisesLatex) {
    html += `<span class="rule-formula" data-latex="${escapeHtml(p)}"></span>\n`;
  }
  html += '</div>\n';

  // Line with name (name is outside, to the right)
  html += '<div class="rule-body">';
  html += '<div class="rule-line"></div>';
  html += `<span class="rule-name" data-latex="${escapeHtml(ruleNameLatex)}"></span>`;
  html += '</div>\n';

  // Conclusion
  html += '<div class="rule-conclusion">\n';
  html += `<span class="rule-formula" data-latex="${escapeHtml(conclusionLatex)}"></span>\n`;
  html += '</div>\n';

  html += '</div>\n';
  return html;
}

// Generate rules section
function generateRules() {
  const rules = calc.rules;
  const contexts = calc.calc_structure_rules_meta?.Contexts || {};

  let html = '<section id="rules">\n<h2>Inference Rules</h2>\n';

  for (const [ctxName, ctxRules] of Object.entries(rules)) {
    const ctxMeta = contexts[ctxName] || {};
    const label = ctxMeta.label || ctxName;

    // Skip structural rules in simplified view (they're not used by proof search)
    if (!FULL_MODE && ctxMeta._unused_by_proofstate) {
      continue;
    }

    html += `<div class="rule-category">\n`;
    html += `<h3>${escapeHtml(label)}</h3>\n`;
    html += `<div class="rules-grid">\n`;

    for (const [ruleName, ruleArray] of Object.entries(ctxRules)) {
      // Get display name from calc_structure_rules
      const rulesMeta = calc.calc_structure_rules?.[ctxName]?.[ruleName] || {};
      const latexName = rulesMeta.latex || rulesMeta.ascii || ruleName;

      html += generateRule(ruleName, ruleArray, latexName);
    }

    html += '</div>\n</div>\n';
  }

  html += '</section>\n';
  return html;
}

// ============================================================
// META VIEW - Documents the framework/schema for defining calculi
// ============================================================

// Generate the type hierarchy section
function generateTypeHierarchy() {
  const structure = calc.calc_structure;

  let html = '<section id="types">\n<h2>Sort Hierarchy</h2>\n';
  html += '<p class="intro">The calculus is built from these fundamental sorts, each with constructors that build terms of that sort.</p>\n';

  // Group types by role
  const sortGroups = {
    'Atomic': ['Atprop', 'Atterm'],
    'Formulas': ['Formula', 'FFormula'],
    'Structures': ['Structure'],
    'Judgments': ['Sequent']
  };

  for (const [groupName, sortNames] of Object.entries(sortGroups)) {
    const presentSorts = sortNames.filter(s => structure[s]);
    if (presentSorts.length === 0) continue;

    html += `<div class="sort-group">\n`;
    html += `<h3>${groupName}</h3>\n`;

    for (const sortName of presentSorts) {
      const constructors = structure[sortName];
      html += `<div class="sort-def">\n`;
      html += `<span class="sort-name">${sortName}</span>\n`;
      html += `<span class="sort-constructors">`;

      const ctors = Object.keys(constructors).map(c => {
        const def = constructors[c];
        if (def.ascii) return `<code>${escapeHtml(def.ascii)}</code>`;
        return `<code>${c}</code>`;
      });
      html += ctors.join(' | ');
      html += `</span>\n`;
      html += `</div>\n`;
    }
    html += `</div>\n`;
  }

  html += '</section>\n';
  return html;
}

// Generate connective schema with polarity information
function generateConnectiveSchema() {
  const structure = calc.calc_structure;
  const polarity = calc.calc_structure_rules_meta?.polarity || {};

  let html = '<section id="connectives-schema">\n<h2>Connective Schema</h2>\n';
  html += '<p class="intro">Each connective has a polarity determining its proof-theoretic behavior: positive connectives are invertible on the right, negative on the left.</p>\n';

  html += '<table class="schema-table">\n';
  html += '<tr><th>Connective</th><th>Arity</th><th>ASCII</th><th>LaTeX</th><th>Polarity</th></tr>\n';

  // Detect arity from syntax pattern: binary if starts with "_ " AND ends with " _" (like "_ * _")
  // After Calc.init(), all connectives are in Formula (Formula_Bin_Op is merged)
  const binaryConnectives = [];
  const unaryConnectives = [];

  if (structure.Formula) {
    for (const [name, def] of Object.entries(structure.Formula)) {
      // Skip internal/structural entries
      if (name.includes('Freevar') || name === 'Formula_Atprop' || name === 'Formula_Bin') continue;
      if (!def.ascii) continue;

      const ascii = def.ascii.trim();
      // Binary: pattern like "_ * _" (starts with _ and ends with _)
      const isBinary = ascii.startsWith('_') && ascii.endsWith('_') && ascii.length > 2;

      if (isBinary) {
        binaryConnectives.push({ name, def });
      } else {
        unaryConnectives.push({ name, def });
      }
    }
  }

  // Output binary connectives first
  for (const { name, def } of binaryConnectives) {
    const ascii = def.ascii.trim();
    const latex = def.latex || ascii;
    const pol = polarity[name] || '-';
    const displayName = name.replace('Formula_', '');

    html += `<tr>`;
    html += `<td><code>${displayName}</code></td>`;
    html += `<td>binary</td>`;
    html += `<td><code>${escapeHtml(ascii)}</code></td>`;
    html += `<td class="latex-cell" data-latex="${escapeHtml(latex)}"></td>`;
    html += `<td class="polarity-${pol}">${pol}</td>`;
    html += `</tr>\n`;
  }

  // Output unary connectives
  for (const { name, def } of unaryConnectives) {
    const ascii = def.ascii.trim();
    const latex = def.latex || ascii;
    const pol = polarity[name] || '-';
    const displayName = name.replace('Formula_', '');

    html += `<tr>`;
    html += `<td><code>${displayName}</code></td>`;
    html += `<td>unary</td>`;
    html += `<td><code>${escapeHtml(ascii)}</code></td>`;
    html += `<td class="latex-cell" data-latex="${escapeHtml(latex)}"></td>`;
    html += `<td class="polarity-${pol}">${pol}</td>`;
    html += `</tr>\n`;
  }

  html += '</table>\n</section>\n';
  return html;
}

// Generate rule schema documentation
function generateRuleSchema() {
  const contexts = calc.calc_structure_rules_meta?.Contexts || {};
  const rules = calc.rules || {};

  let html = '<section id="rule-schema">\n<h2>Rule Schema</h2>\n';
  html += '<p class="intro">Inference rules are organized by context. Each rule is an array: <code>[conclusion, premise₁, premise₂, ...]</code></p>\n';

  html += '<table class="schema-table">\n';
  html += '<tr><th>Context</th><th>Label</th><th>Rule Count</th><th>Description</th></tr>\n';

  for (const [ctxName, ctxMeta] of Object.entries(contexts)) {
    const label = ctxMeta.label || ctxName;
    const ruleCount = rules[ctxName] ? Object.keys(rules[ctxName]).length : 0;

    let desc = '';
    if (ctxMeta._unused_by_proofstate) {
      desc = 'Display postulates (structural)';
    } else if (ctxName === 'RuleZer') {
      desc = 'Axioms (no premises)';
    } else if (ctxName === 'RuleCut') {
      desc = 'Cut rule for composition';
    } else if (ctxName === 'RuleU') {
      desc = 'Single-premise logical rules';
    } else if (ctxName === 'RuleBin') {
      desc = 'Two-premise logical rules';
    }

    const unusedClass = ctxMeta._unused_by_proofstate ? ' class="unused"' : '';

    html += `<tr${unusedClass}>`;
    html += `<td><code>${ctxName}</code></td>`;
    html += `<td>${escapeHtml(label)}</td>`;
    html += `<td>${ruleCount}</td>`;
    html += `<td>${desc}</td>`;
    html += `</tr>\n`;
  }

  html += '</table>\n';
  html += '<p class="note">Rows marked as unused are display postulates not used by focused proof search.</p>\n';
  html += '</section>\n';
  return html;
}

// Generate metavariable conventions
function generateMetaConventions() {
  let html = '<section id="metavars">\n<h2>Metavariable Conventions</h2>\n';
  html += '<p class="intro">Rules use metavariables to range over terms of each sort. The ASCII syntax uses prefixes to distinguish sorts.</p>\n';

  html += '<table class="schema-table">\n';
  html += '<tr><th>Sort</th><th>ASCII Pattern</th><th>Math Notation</th><th>Example</th></tr>\n';

  const conventions = [
    ['Structure', '?X, ?Y, ?Z', 'Γ, Δ, Σ', 'Contexts/antecedents'],
    ['Formula', 'F?A, F?B, F?C', 'A, B, C', 'Formulas in rules'],
    ['Atprop', 'A?A, A?B', 'p, q', 'Atomic propositions'],
    ['Atterm', 'AT?A, AT?B', 'x, y', 'Term variables'],
    ['Term', 'T?A', 't, u', 'Term expressions'],
    ['(Anonymous)', '--', '·', 'Placeholder term'],
  ];

  html += conventions.map(([sort, ascii, math, example]) =>
    `<tr><td><code>${sort}</code></td><td><code>${escapeHtml(ascii)}</code></td>` +
    `<td class="latex-cell" data-latex="${escapeHtml(math)}"></td><td>${example}</td></tr>`
  ).join('\n');

  html += '</table>\n</section>\n';
  return html;
}

// Generate the display calculus methodology section
function generateMethodology() {
  let html = '<section id="methodology">\n<h2>Display Calculus Methodology</h2>\n';

  html += `<div class="methodology-item">
<h3>Display Property</h3>
<p>Any substructure occurrence in a sequent can be "displayed" as the entire
antecedent or succedent via structural rules. This enables modular proof of cut elimination.</p>
</div>

<div class="methodology-item">
<h3>Focused Proof Search</h3>
<p>The proof search implementation uses focused sequent calculus rather than pure display calculus.
Contexts are multisets; structural rules are implicit. Focusing alternates between:</p>
<ul>
<li><strong>Inversion phase:</strong> Apply invertible rules eagerly (negative-right, positive-left)</li>
<li><strong>Focus phase:</strong> Choose a formula and apply non-invertible rules</li>
</ul>
</div>

<div class="methodology-item">
<h3>Polarity</h3>
<p>Connective polarity determines invertibility:</p>
<ul>
<li><strong>Positive:</strong> Right rules non-invertible, left rules invertible</li>
<li><strong>Negative:</strong> Right rules invertible, left rules non-invertible</li>
</ul>
</div>`;

  html += '</section>\n';
  return html;
}

// Generate meta-view HTML
function generateMetaHTML() {
  const calcName = calc.calc_name || 'Calculus';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${calcName} - Framework Schema</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
  <style>
    :root {
      --bg: #fff;
      --fg: #222;
      --accent: #4a5568;
      --border: #e2e8f0;
      --positive: #38a169;
      --negative: #e53e3e;
      --note-bg: #faf5e4;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1a202c;
        --fg: #e2e8f0;
        --accent: #a0aec0;
        --border: #4a5568;
        --positive: #68d391;
        --negative: #fc8181;
        --note-bg: #2d3748;
      }
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
    }

    h1 { border-bottom: 2px solid var(--border); padding-bottom: 0.5rem; }
    h2 { color: var(--accent); margin-top: 2.5rem; }
    h3 { color: var(--accent); font-size: 1rem; margin: 1rem 0 0.5rem; }

    code {
      background: var(--border);
      padding: 0.1em 0.3em;
      border-radius: 3px;
      font-size: 0.9em;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }

    th, td {
      border: 1px solid var(--border);
      padding: 0.5rem 1rem;
      text-align: left;
    }

    th { background: var(--border); }

    .subtitle { color: var(--accent); margin-top: -1rem; }
    .intro { color: var(--accent); font-style: italic; margin-bottom: 1rem; }
    .note { font-size: 0.9em; color: var(--accent); margin-top: 0.5rem; }

    .sort-group { margin-bottom: 1.5rem; }
    .sort-def {
      display: flex;
      gap: 1rem;
      padding: 0.3rem 0;
      border-bottom: 1px dashed var(--border);
    }
    .sort-name {
      font-weight: bold;
      min-width: 120px;
      color: var(--accent);
    }
    .sort-constructors { font-family: monospace; }

    .polarity-positive { color: var(--positive); font-weight: bold; }
    .polarity-negative { color: var(--negative); font-weight: bold; }

    .unused { opacity: 0.6; }
    .unused td { font-style: italic; }

    .methodology-item {
      background: var(--note-bg);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
      border-left: 3px solid var(--accent);
    }
    .methodology-item h3 { margin-top: 0; }
    .methodology-item ul { margin: 0.5rem 0; padding-left: 1.5rem; }

    @media print {
      body { max-width: none; }
      section { break-inside: avoid; }
    }
  </style>
</head>
<body>
  <h1>${calcName}</h1>
  <p class="subtitle">Framework Schema</p>

  ${generateTypeHierarchy()}
  ${generateConnectiveSchema()}
  ${generateRuleSchema()}
  ${generateMetaConventions()}
  ${generateMethodology()}

  <script>
    document.querySelectorAll('[data-latex]').forEach(el => {
      try {
        katex.render(el.dataset.latex, el, { displayMode: false, throwOnError: false });
      } catch (e) {
        el.textContent = el.dataset.latex;
      }
    });
    document.querySelectorAll('.latex-cell').forEach(el => {
      try {
        katex.render(el.dataset.latex, el, { displayMode: false, throwOnError: false });
      } catch (e) {
        el.textContent = el.dataset.latex;
      }
    });
  </script>
</body>
</html>`;
}

// Generate full HTML document
function generateHTML() {
  const calcName = calc.calc_name || 'Calculus';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${calcName} - Calculus Specification</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
  <style>
    :root {
      --bg: #fff;
      --fg: #222;
      --accent: #4a5568;
      --border: #e2e8f0;
      --rule-line: #2d3748;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1a202c;
        --fg: #e2e8f0;
        --accent: #a0aec0;
        --border: #4a5568;
        --rule-line: #e2e8f0;
      }
    }

    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
    }

    h1 {
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.5rem;
    }

    h2 {
      color: var(--accent);
      margin-top: 2rem;
    }

    h3 {
      color: var(--accent);
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    code {
      background: var(--border);
      padding: 0.1em 0.3em;
      border-radius: 3px;
      font-size: 0.9em;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }

    th, td {
      border: 1px solid var(--border);
      padding: 0.5rem 1rem;
      text-align: left;
    }

    th {
      background: var(--border);
    }

    .syntax-rule {
      font-family: monospace;
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: var(--border);
      border-radius: 4px;
    }

    .type-name {
      font-weight: bold;
      color: var(--accent);
    }

    .rules-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 2.5rem 3rem;
      margin: 1rem 0;
    }

    .inference-rule {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
    }

    .rule-premises {
      display: flex;
      gap: 2rem;
      padding-bottom: 0.25rem;
      min-height: 1.2em;
    }

    .rule-body {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }

    .rule-line {
      flex: 1;
      border-top: 1.5px solid var(--rule-line);
      min-width: 2rem;
    }

    .rule-name {
      font-size: 0.85em;
      color: var(--accent);
      white-space: nowrap;
      padding-left: 0.3rem;
    }

    .rule-conclusion {
      padding-top: 0.25rem;
    }

    .rule-formula {
      white-space: nowrap;
    }

    .no-premise {
      min-width: 1rem;
    }

    .rule-category {
      margin-bottom: 2rem;
    }

    @media print {
      body { max-width: none; }
      .rule-category { break-inside: avoid; }
    }

    .subtitle {
      color: var(--accent);
      margin-top: -1rem;
    }
  </style>
</head>
<body>
  <h1>${calcName}</h1>
  <p class="subtitle">${FULL_MODE ? 'Full Specification' : 'Reference Card'}</p>

  ${generateMetavariables()}
  ${generateConnectives()}
  ${generateRules()}

  <script>
    // Render all LaTeX
    document.querySelectorAll('[data-latex]').forEach(el => {
      try {
        katex.render(el.dataset.latex, el, { displayMode: false, throwOnError: false });
      } catch (e) {
        el.textContent = el.dataset.latex;
      }
    });
    document.querySelectorAll('.latex-cell').forEach(el => {
      try {
        katex.render(el.dataset.latex, el, { displayMode: false, throwOnError: false });
      } catch (e) {
        el.textContent = el.dataset.latex;
      }
    });
  </script>
</body>
</html>`;
}

// Output
if (META_MODE) {
  console.log(generateMetaHTML());
} else {
  console.log(generateHTML());
}
