#!/usr/bin/env node
// TODO - to get rid of shift-reduce conflicts for "e bin_op e" expressions, I cannot have non-terminal bin_op rules, therefore they should be propagated up to generate multiple "e '+' e" rules.

const compare = require("../lib/compare.js");
const sub = require("../lib/substitute.js");

const DEBUG = !!process.env["DEBUG"];
const args = process.argv.slice(2);
let formulaStr = "I |- TT? S. TT? S. TT? Z : NNat";
let formulaStr2 = "I |- TT? S. T? n: Nat";

const f1 = args && args[0] || formulaStr;
const f2 = args && args[1] || formulaStr2;

const calc = require('../ll.json');
const calcParser = require("../lib/parser.js");
const parser = calcParser(calc).parser;

let n1 = parser.parse(f1)


Object.keys(calc.rules).forEach(ctxName => {
  let ctx = calc.rules[ctxName];
  Object.keys(ctx).forEach(ruleName => {
    let rule = ctx[ruleName];
    let conclusion = rule[0];
    let n2 = parser.parse(conclusion)
    let unifier = compare(n1, n2);
    if(!!unifier) {
      let remaining = rule.slice(1)
      .map(r => parser.parse(r))
      .map(r => unifier.reduceRight((rule, u) => sub(rule, u[0], u[1]), r))
      .map(r => r.toString())
      .join("\n  ")
      console.log(`${ctxName}.${ruleName}\n  ${remaining}\n`);
      // console.log("    "+ unifier.map(u => u.map(r => r.toString()).join(" = ")).join("\n    "));
    }
  })
})
